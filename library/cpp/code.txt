--- CODE_HEADER
/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org>
 */

// AUTO-GENERATED FILE. DO NOT EDIT!
// Generated by the protogen $1$ compiler <https://github.com/brunexgeek/protogen>
// Source: $2$

#ifndef $3$
#define $3$

#ifdef PROTOGEN_VERSION
   #undef PROTOGEN_VERSION
#endif

#include <string>
#include <stdint.h>
#include <iterator>
#include <sstream>
#include <iostream>
#include <vector>
#include <list>
#include <cstdlib>
#include <locale.h>
#include <stdexcept>
#include <forward_list>

#undef PROTOGEN_NS
#define PROTOGEN_NS protogen_$4$
------

--- CODE_TOKENIZER
namespace PROTOGEN_NS {

enum class token_id
{
    NONE, EOS, OBJS, OBJE, COLON, COMMA, STRING, ARRS,
    ARRE, NIL, TRUE, FALSE, NUMBER,
};

struct token
{
    token_id id = token_id::NONE;
    std::string value;

    token() {}
    token( const token &that ) : id(that.id), value(that.value) {}
    token( token &&that ) { swap(that); }
    token( token_id id, const std::string &value = "" ) : id(id), value(value) {}
    token &operator=( const token &that ) { id = that.id, value = that.value; return *this; }
    void swap( token &that ) { std::swap(id, that.id); value.swap(that.value); }
};

static bool parse_string( std::istream &input, token &output )
{
    output.id = token_id::STRING;

    while (!input.eof())
    {
        int c = input.get();
        if (c == '"') return true;

        if (c == '\\')
        {
            c = input.get();
            switch (c)
            {
                case '"':  c = '"'; break;
                case '\\': c = '\\'; break;
                case '/':  c = '/'; break;
                case 'b':  c = '\b'; break;
                case 'f':  c = '\f'; break;
                case 'r':  c = '\r'; break;
                case 'n':  c = '\n'; break;
                case 't':  c = '\t'; break;
                default: return false;
            }
        }

        if (c <= 0) return false;
        output.value += (char) c;
    }

    return false;
}

static bool parse_keyword( std::istream &input, const std::string &keyword )
{
    for (auto c : keyword)
        if (input.get() != c) return false;
    return true;
}

static bool parse_number( std::istream &input, token &output )
{
    output.id = token_id::NUMBER;

    while (!input.eof())
    {
        int c = input.get();
        if (c == '.' || (c >= '0' && c <= '9') || c == 'e' || c == 'E' || c == '+' || c == '-')
            output.value += c;
        else
        {
            input.unget();
            break;
        }
    }

    return true;
}

class tokenizer
{
    public:
        tokenizer( std::istream &input );
        token &next();
        token &current();
        void unget();
    protected:
        token current_;
        std::istream &input_;
        std::forward_list<token> stack_;
};

tokenizer::tokenizer( std::istream &input ) : input_(input) {}

token &tokenizer::current()
{
    return current_;
}

token &tokenizer::next()
{
    if (!stack_.empty())
    {
        current_ = stack_.front();
        stack_.pop_front();
        return current_;
    }

    current_.id = token_id::NONE;
    current_.value.clear();

    while (!input_.eof())
    {
        int c = input_.get();
        switch (c)
        {
            case ' ':
            case '\t':
            case '\n':
            case '\r':
                break;
            case '{': return current_ = token(token_id::OBJS);
            case '}': return current_ = token(token_id::OBJE);
            case '[': return current_ = token(token_id::ARRS);
            case ']': return current_ = token(token_id::ARRE);
            case ':': return current_ = token(token_id::COLON);
            case ',': return current_ = token(token_id::COMMA);
            case '"':
                parse_string(input_, current_);
                return current_;
            case 'n':
                if (!parse_keyword(input_, "ull")) return current_;
                return current_ = token_id(token_id::NIL);
            case 't':
                if (!parse_keyword(input_, "rue")) return current_;
                return current_ = token_id(token_id::TRUE);
            case 'f':
                if (!parse_keyword(input_, "alse")) return current_;
                return current_ = token_id(token_id::FALSE);
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                current_.value += c;
                if (!parse_number(input_, current_)) return current_;
                return current_;
            default:
                return current_ = token(token_id::NONE);
        }
    }

    return current_ = token(token_id::EOS);
}

void tokenizer::unget()
{
    token temp;
    temp.swap(current_);
    stack_.push_front(temp);
}

template<typename CharT, typename TraitsT = std::char_traits<CharT> >
class vector_streambuf : public std::basic_streambuf<CharT, TraitsT> {
public:
    vector_streambuf(std::vector<CharT> &that) {
        this->setg(that.data(), that.data(), that.data() + that.size());
    }
};

} // PROTOGEN_NS
------

--- CODE_MACROS
#ifndef PROTOGEN_CPP_ENABLE_ERRORS
    #define PROTOGEN_REV(err,input,name,type) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REI(err,input,name) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REF(err,input,name) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REM(err,input,name) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REG(err,input,name) return PROTOGEN_NS::parse_result::ERROR
#else
    #define PROTOGEN_REV(err,input,name,type) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Invalid '") + type + "' value in field '" + name + "'"; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REI(err,input,name) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Unable to skip field '") + name + "'"; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_RETERR_FORMAT(err,input,name) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Invalid JSON after field '") + name + "'"; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REM(err,input,name) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Missing required field '") + name + "'"; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REG(err,input,msg) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = msg; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
#endif

#undef PROTOGEN_TRAIT
#define PROTOGEN_TRAIT(M) \
	namespace PROTOGEN_NS { \
		template<> struct traits<M> { \
			static void clear( M &value ) { value.clear(); } \
			static void write( std::ostream &out, const M &value ) { value.serialize(out); } \
			static PROTOGEN_NS::parse_result read( PROTOGEN_NS::tokenizer &tok, M &value, \
                bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) { return value.deserialize(tok, required, err); } \
			static void swap( M &a, M &b ) { a.swap(b); } \
		}; \
	}

#undef PROTOGEN_FIELD
#define PROTOGEN_FIELD(M) \
	namespace PROTOGEN_NS { \
        template<> class Field<M> { \
		protected: \
			M value_; \
		public: \
			Field() { clear(); } \
			Field( Field<M> &&that ) { this->value_.swap(that.value_); } \
			void swap( Field<M> &that ) { traits<M>::swap(this->value_, that.value_); } \
            void swap( M &that ) { traits<M>::swap(this->value_, that); } \
			const M &operator()() const { return value_; } \
			M &operator()() { return value_; } \
			void operator ()(const M &value ) { this->value_ = value; } \
			bool undefined() const { return value_.undefined(); } \
			void clear() { traits<M>::clear(value_); } \
			Field<M> &operator=( const Field<M> &that ) { this->value_ = that.value_; return *this; } \
			Field<M> &operator=( const M &that ) { this->value_ = that; return *this; } \
			bool operator==( const Field<M> &that ) const { return this->value_ == that.value_; } \
			bool operator==( const M &that ) const { return this->value_ == that; } \
			explicit operator M() { return this->value_; } \
			explicit operator M() const { return this->value_; } \
	    }; \
    }
------

--- CODE_BLOCK_2

namespace PROTOGEN_NS {

enum class parse_result
{
    OK, ERROR, UNDEFINED
};

struct ErrorInfo
{
    int line;
    int column;
    std::string message;
    bool set;
    ErrorInfo() : line(0), column(0), set(false) {}
};

// proto3 numerics
template<typename T> struct traits
{
    static void clear( T &value ) { value = (T) 0; }
    static void write( std::ostream &out, const T &value ) { out << value; }

    static parse_result read( tokenizer &tok, T &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::NUMBER) return parse_result::ERROR;

#if defined(_WIN32) || defined(_WIN64)
        static _locale_t loc = _create_locale(LC_NUMERIC, "C");
        if (loc == NULL) return parse_result::ERROR;
        value = static_cast<T>(_strtod_l(tt.value.c_str(), NULL, loc));
#else
        static locale_t loc = newlocale(LC_NUMERIC_MASK | LC_MONETARY_MASK, "C", 0);
        if (loc == 0) return parse_result::ERROR;
        uselocale(loc);
        value = static_cast<T>(strtod(tt.value.c_str(), NULL));
        uselocale(LC_GLOBAL_LOCALE);
#endif
        return parse_result::OK;
    }
    static void swap( T &a, T &b ) { T temp = a; a = b; b = temp; }
};

// proto3 'bool'
template<> struct traits<bool>
{
    static void clear( bool &value ) { value = false; }
    static void write( std::ostream &out, const bool &value ) { out << ((value) ? "true" : "false"); }

    static parse_result read(tokenizer &tok, bool &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::TRUE && tt.id != token_id::FALSE) return parse_result::ERROR;
        value = tt.id == token_id::TRUE;
        return parse_result::OK;
    }
    static void swap( bool &a, bool &b ) { bool temp = a; a = b; b = temp; }
};

// proto3 'string'
template<> struct traits<std::string>
{
    static void clear( std::string &value ) { value.clear(); }
    static void write( std::ostream &out, const std::string &value )
    {
        out << '"';
        for (std::string::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            switch (*it)
            {
                case '"':  out << "\\\""; break;
                case '\\': out << "\\\\"; break;
                case '/':  out << "\\/"; break;
                case '\b': out << "\\b"; break;
                case '\f': out << "\\f"; break;
                case '\r': out << "\\r"; break;
                case '\n': out << "\\n"; break;
                case '\t': out << "\\t"; break;
                default:   out << *it;
            }
        }
        out << '"';
    }

    static parse_result read( tokenizer &tok, std::string &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::STRING) return parse_result::ERROR;
        value = tt.value;
        return parse_result::OK;
    }
    static void swap( std::string &a, std::string &b ) { a.swap(b); }
};
------

--- CODE_REPEATED_TRAIT
// proto3 'repeated' with $1$ as container
template <typename T> struct traits< $1$<T> >
{
    static void clear( $1$<T> &value ) { value.clear(); }

    static bool write( std::ostream &out, const $1$<T> &value )
    {
        bool begin = true;
        out << '[';
        for (typename $1$<T>::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            if (!begin) out << ",";
            begin = false;
            traits<T>::write(out, *it);
        }
        out << ']';
        return true;
    }

    static parse_result read( tokenizer &tok, $1$<T> &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::ARRS) return parse_result::ERROR;
        while (true)
        {
            T entry;
            parse_result res = traits<T>::read(tok, entry, required, err);
            if (res == parse_result::ERROR) return parse_result::ERROR;
            if (res == parse_result::OK) value.push_back(entry);
            tt = tok.next();
            if (tt.id != token_id::COMMA) break;
        }
        if (tt.id != token_id::ARRE) return parse_result::ERROR;
        return parse_result::OK;
    }

    static void swap( $1$<T> &a, $1$<T> &b ) { a.swap(b); }
};
------

--- CODE_BLOCK_3

// Base64 encoder/decoder based on Joe DF's implementation
// Original source at <https://github.com/joedf/base64.c> (MIT licensed)
static const char *B64_SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
template <> struct traits< std::vector<uint8_t> >
{
    static void clear( std::vector<uint8_t> &value ) { value.clear(); }

    static int b64_int( int ch )
    {
        if (ch == '+') return 62;
        if (ch == '/') return 63;
        if (ch == '=') return 64;
        if (ch >= '0' && ch <= '9') return ch + 4;
        if (ch >= 'A' && ch <= 'Z') return ch - 'A';
        if (ch >= 'a' && ch <= 'z') return (ch - 'a') + 26;
        return 0;
    }

    static bool write( std::ostream &out, const std::vector<uint8_t> &value )
    {
        char o[5] = { 0 };
        size_t i = 0;
        size_t size = value.size();

        out << '"';

        for (i = 0; i + 2 < size; i += 3)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
            o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) | ((value[i+2] & 0xC0) >> 6) ];
            o[3] = B64_SYMBOLS[ value[i+2] & 0x3F ];
            out << o;
        }

        if (size - i)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) ];
            o[2] = '=';
            o[3] = '=';

            if (size - i == 2)
            {
                o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
                o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) ];
            }

            out << o;
        }
        out << '"';

        return true;
    }

    static parse_result read( tokenizer &tok, std::vector<uint8_t> &array, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;

        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::STRING) return parse_result::ERROR;

        size_t k = 0;
        int s[4];
        const char *ptr = tt.value.c_str();

        while (true)
        {
            // read 4 characters
            for (size_t j = 0; j < 4; ++j)
            {
                int ch = *ptr++;
                if (ch == 0) return (j == 0) ? parse_result::OK : parse_result::ERROR;
                s[j] = PROTOGEN_NS::traits< std::vector<uint8_t> >::b64_int(ch);
            }
            // decode base64 tuple
            array.push_back( ((s[0] & 0xFF) << 2 ) | ((s[1] & 0x30) >> 4) );
            if (s[2] != 64)
            {
                array.push_back( ((s[1] & 0x0F) << 4) | ((s[2] & 0x3C) >> 2) );
                if ((s[3]!=64))
                {
                    array.push_back( ((s[2] & 0x03) << 6) | s[3] );
                    k+=3;
                }
                else
                    k+=2;
            }
            else
                k+=1;
        }
    }

    static void swap( std::vector<uint8_t> &a, std::vector<uint8_t> &b ) { a.swap(b); }
};

// primitive fields
template<typename T> class Field
{
    protected:
        T value_;
        bool undefined_;
    public:
        Field() { clear(); }
        Field( const Field<T> &that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_ = that.value_; }
        Field( Field<T> &&that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_.swap(that.value_); }
        void swap( Field<T> &that ) { traits<T>::swap(this->value_, that.value_); traits<bool>::swap(this->undefined_, that.undefined_); }
        void swap( T &that ) { traits<T>::swap(this->value_, that); undefined_ = false; }
        const T &operator()() const { return value_; }
        void operator ()(const T &value ) { this->value_ = value; this->undefined_ = false; }
        bool undefined() const { return undefined_; }
        void clear() { traits<T>::clear(value_); undefined_ = true; }
        Field<T> &operator=( const Field<T> &that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_ = that.value_; return *this; }
        Field<T> &operator=( const T &that ) { this->undefined_ = false; this->value_ = that; return *this; }
        bool operator==( const T &that ) const { return !this->undefined_ && this->value_ == that; }
        bool operator==( const Field<T> &that ) const { return this->undefined_ == that.undefined_ && this->value_ == that.value_;  }
        explicit operator T() { return this->value_; }
        explicit operator T() const { return this->value_; }
};

------

--- CODE_REPEATED_FIELD
template< class T, class CT > class RepeatedField
{
     protected:
        CT value_;
     public:
        RepeatedField() {}
        RepeatedField( const RepeatedField<T, CT> &that ) { this->value_ = that.value_; }
        RepeatedField( RepeatedField<T, CT> &&that ) { this->value_.swap(that.value_); }
        void swap( RepeatedField<T, CT> &that ) { traits< CT >::swap(this->value_, that.value_); }
        const CT &operator()() const { return value_; }
        CT &operator()() { return value_; }
        bool undefined() const { return value_.size() == 0; }
        void clear() { value_.clear(); }
        RepeatedField<T, CT> &operator=( const RepeatedField<T, CT> &that ) { this->value_ = that.value_; return *this; }
        bool operator==( const RepeatedField<T, CT> &that ) const { return this->value_ == that.value_; }
 };
------


--- CODE_PARENT_CLASS
// messages parent class
class Message
{
    public:
        virtual void serialize( std::string &out ) const = 0;
        virtual void serialize( std::vector<char> &out ) const = 0;
        virtual void serialize( std::ostream &out ) const = 0;
        virtual bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual bool deserialize( std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual void clear() = 0;
        virtual bool undefined() const = 0;
};
------

--- CODE_STRING_REVEAL
namespace json {
template<typename T>
static std::string reveal( const T *value, size_t length )
{
	std::string result(length, ' ');
	for (size_t i = 0; i < length; ++i)
		result[i] = (T) ((int) value[i] ^ 0x33);
	return result;
}
}
------

--- CODE_BLOCK_4
namespace json {

// Write a complete JSON field
template<typename T>
static bool write( std::ostream &out, bool &first, const std::string &name, const T &value )
{
    if (!first) out << ',';
    out << '"' << name << "\":";
    traits<T>::write(out, value);
    first = false;
    return true;
}

static parse_result next_field( tokenizer &tok )
{
    token tt = tok.next();
    if (tt.id == token_id::COMMA) return parse_result::OK;
    if (tt.id == token_id::OBJE || tt.id == token_id::ARRE)
    {
        tok.unget();
        return parse_result::OK;
    }
    return parse_result::ERROR;
}

static parse_result ignore_value( tokenizer &tok );

static parse_result ignore_array( tokenizer &tok )
{
    if (tok.next().id != token_id::OBJS) return parse_result::ERROR;

    while (true)
    {
        if (ignore_value(tok) == parse_result::ERROR) return parse_result::ERROR;
        if (tok.next().id != token_id::COMMA) break;
    }
    if (tok.next().id != token_id::OBJE) return parse_result::ERROR;

    return parse_result::OK;
}

static parse_result ignore_object( tokenizer &tok )
{
    if (tok.next().id != token_id::OBJS) return parse_result::ERROR;

    while (true)
    {
        if (tok.next().id != token_id::STRING) return parse_result::ERROR;
        if (tok.next().id != token_id::COLON) return parse_result::ERROR;
        if (ignore_value(tok) == parse_result::ERROR) return parse_result::ERROR;
        if (tok.next().id != token_id::COMMA) break;
    }
    if (tok.next().id != token_id::OBJE) return parse_result::ERROR;

    return parse_result::OK;
}

static parse_result ignore_value( tokenizer &tok )
{
    switch (tok.next().id)
    {
        case token_id::NONE:
            return parse_result::ERROR;
        case token_id::OBJS:
            tok.unget();
            if (ignore_object(tok) == parse_result::ERROR)
                return parse_result::ERROR;
        case token_id::ARRS:
            tok.unget();
            if (ignore_array(tok) == parse_result::ERROR)
                return parse_result::ERROR;
        case token_id::STRING:
        case token_id::NUMBER:
        case token_id::NIL:
        case token_id::TRUE:
        case token_id::FALSE:
            break;
        default:
            return parse_result::ERROR;
    }
    return parse_result::OK;
}


} // namespace json
} // namespace PROTOGEN_NS

------

--- CODE_SERIALIZER
    void serialize( std::string &out ) const {
        std::stringstream ss;
        serialize(ss);
        out = ss.str();
    }
    void serialize( std::vector<char> &out ) const {
        PROTOGEN_NS::vector_streambuf<char> sb(out);
        std::ostream os(&sb);
        serialize(os);
    }
------

--- CODE_DESERIALIZER
    bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		bool skip = in.flags() & std::ios_base::skipws;
		std::noskipws(in);
        PROTOGEN_NS::tokenizer tok(in);
		bool result = this->deserialize(tok, required, err) != PROTOGEN_NS::parse_result::ERROR;
		if (skip) std::skipws(in);
		return result;
	}
	bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		std::istringstream is(in);
		return this->deserialize(is, required, err);
	}
	bool deserialize( std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::vector_streambuf<char> sb(in);
        std::istream is(&sb);
		return this->deserialize(is, required, err);
	}
------