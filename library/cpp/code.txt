--- CODE_HEADER
/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <http://unlicense.org>
 */

// AUTO-GENERATED FILE. DO NOT EDIT!
// Generated by the protogen $1$ compiler <https://github.com/brunexgeek/protogen>
// Source: $2$

#ifndef $3$
#define $3$

#ifdef PROTOGEN_VERSION
   #undef PROTOGEN_VERSION
#endif

#include <string>
#include <stdint.h>
#include <iterator>
#include <sstream>
#include <iostream>
#include <vector>
#include <list>
#include <cstdlib>
#include <locale.h>
#include <stdexcept>
#include <forward_list>

#undef PROTOGEN_NS
#define PROTOGEN_NS protogen_$4$
------

--- CODE_TOKENIZER
namespace PROTOGEN_NS {

enum class token_id
{
    NONE, EOS, OBJS, OBJE, COLON, COMMA, STRING, ARRS,
    ARRE, NIL, TRUE, FALSE, NUMBER,
};

struct token
{
    token_id id = token_id::NONE;
    std::string value;

    token() {}
    token( const token &that ) : id(that.id), value(that.value) {}
    token( token &&that ) { swap(that); }
    token( token_id id, const std::string &value = "" ) : id(id), value(value) {}
    token &operator=( const token &that ) { id = that.id, value = that.value; return *this; }
    void swap( token &that ) { std::swap(id, that.id); value.swap(that.value); }
};

class ostream
{
    public:
        ostream() = default;
        virtual ~ostream() = default;
        virtual ostream &operator<<( const std::string &value ) = 0;
        virtual ostream &operator<<( const char *value ) = 0;
        virtual ostream &operator<<( char *value ) = 0;
        virtual ostream &operator<<( char value ) = 0;
        template<class T> ostream &operator<<( T value )
        {
            this->operator<<( std::to_string(value) );
            return *this;
        }
};

template<typename I>
class iterator_ostream : public ostream
{
    public:
        iterator_ostream( I& first ) : beg_(first)
        {
        }
        ostream & operator<<( char value ) override
        {
            *++beg_ = value;
            return *this;
        }
        ostream & operator<<( const std::string &value ) override
        {
            for (auto it = value.begin(); it != value.end(); ++it)
                *++beg_ = *it;
            return *this;
        }
        ostream & operator<<( const char *value ) override
        {
            while (*value != 0) *++beg_ = *value++;
            return *this;
        }
        ostream & operator<<( char *value ) override { return *this << value; }

    protected:
        I beg_;
};

class istream
{
    public:
        istream() = default;
        virtual ~istream() = default;
        virtual int peek() = 0;
        virtual int get() = 0;
        virtual bool eof() const = 0;
        virtual int line() const = 0;
        virtual int column() const = 0;
};

template<typename I>
class iterator_istream : public istream
{
    public:
        iterator_istream( const I& first, const I& last ) : beg_(first), end_(last), line_(1),
            column_(0)
        {
        }
        int peek() override
        {
            if (beg_ == end_) return 0;
            return *beg_;
        }
        int get() override
        {
            if (beg_ == end_) return 0;
            ++column_;
            int c = *beg_++;
            if (c == '\n')
            {
                ++line_;
                column_ = 0;
            }
            return c;
        }
        bool eof() const override { return beg_ == end_; }
        int line() const override { return line_; }
        int column() const override { return column_; }
    protected:
        I beg_, end_;
        int line_, column_;
};

class tokenizer
{
    public:
        tokenizer( istream &input ) : input_(input)
        {
        }

        int line() const { return input_.line(); }
        int column() const { return input_.column(); }

        token &next()
        {
            if (!stack_.empty())
            {
                current_ = stack_.front();
                stack_.pop_front();
                return current_;
            }
            current_.id = token_id::NONE;
            current_.value.clear();
            while (!input_.eof())
            {
                int c = input_.get();
                switch (c)
                {
                    case ' ':
                    case '\t':
                    case '\r':
                    case '\n':
                        break;
                    case '{': return current_ = token(token_id::OBJS);
                    case '}': return current_ = token(token_id::OBJE);
                    case '[': return current_ = token(token_id::ARRS);
                    case ']': return current_ = token(token_id::ARRE);
                    case ':': return current_ = token(token_id::COLON);
                    case ',': return current_ = token(token_id::COMMA);
                    case '"':
                        parse_string(current_);
                        return current_;
                    case 'n':
                        if (!parse_keyword("ull")) return current_;
                        return current_ = token_id(token_id::NIL);
                    case 't':
                        if (!parse_keyword("rue")) return current_;
                        return current_ = token_id(token_id::TRUE);
                    case 'f':
                        if (!parse_keyword("alse")) return current_;
                        return current_ = token_id(token_id::FALSE);
                    case '-':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        current_.value += (char) c;
                        if (!parse_number(current_)) return current_;
                        return current_;
                    default:
                        return current_ = token(token_id::NONE);
                }
            }

            return current_ = token(token_id::EOS);
        }

        void unnext()
        {
            token temp;
            temp.swap(current_);
            stack_.push_front(temp);
        }

        token &current() { return current_; }

    protected:
        token current_;
        istream &input_;
        std::forward_list<token> stack_;

        bool parse_string( token &output )
        {
            output.id = token_id::STRING;

            while (!input_.eof())
            {
                int c = input_.get();
                if (c == '"') return true;

                if (c == '\\')
                {
                    c = input_.get();
                    switch (c)
                    {
                        case '"':  c = '"'; break;
                        case '\\': c = '\\'; break;
                        case '/':  c = '/'; break;
                        case 'b':  c = '\b'; break;
                        case 'f':  c = '\f'; break;
                        case 'r':  c = '\r'; break;
                        case 'n':  c = '\n'; break;
                        case 't':  c = '\t'; break;
                        default: return false;
                    }
                }

                if (c <= 0) return false;
                output.value += (char) c;
            }

            return false;
        }

        bool parse_keyword( const std::string &keyword )
        {
            for (auto c : keyword)
                if (input_.get() != c) return false;
            return true;
        }

        bool parse_number( token &output )
        {
            output.id = token_id::NUMBER;

            while (!input_.eof())
            {
                int c = input_.peek();
                if (c == '.' || (c >= '0' && c <= '9') || c == 'e' || c == 'E' || c == '+' || c == '-')
                {
                    output.value += (char) c;
                    input_.get();
                }
                else
                    break;
            }

            return true;
        }
};

template<class T>
class mem_iterator
{
    static_assert(std::is_arithmetic<T>::value, "Invalid template parameters");
    public:
        mem_iterator( const T *begin, size_t count ) : cursor(begin), end(begin + count), empty(0)
        {
        }
        mem_iterator &operator++(int)
        {
            if (cursor < end) cursor++;
            return *this;
        }
        const T &operator*() const
        {
            if (cursor >= end) return empty;
            return *cursor;
        }
        bool operator==( const mem_iterator<T> &that ) const
        {
            return cursor == that.cursor;
        }
    protected:
        const T *cursor;
        const T *end;
        T empty;
};

} // PROTOGEN_NS
------

--- CODE_MACROS
#define PGERR_IGNORE_FAILED      -1
#define PGERR_MISSING_FIELD      -2
#define PGERR_INVALID_SEPARATOR  -3
#define PGERR_INVALID_VALUE      -4
#define PGERR_INVALID_OBJECT     -5
#define PGERR_INVALID_NAME       -6

#ifndef PROTOGEN_CPP_ENABLE_ERRORS
    #define PROTOGEN_REI(err,tok,name) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REM(err,tok,name) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_RES(err,tok) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REV(err,tok,name,type) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REO(err,tok) return PROTOGEN_NS::parse_result::ERROR
    #define PROTOGEN_REN(err,tok) return PROTOGEN_NS::parse_result::ERROR
#else
    #define PROTOGEN_REI(err,tok,name) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Unable to ignore field '"; \
             err->message += name; \
             err->message += "'"; \
             err->code = PGERR_IGNORE_FAILED; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REM(err,tok,name) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Missing required field '"; \
             err->message += name; \
             err->message += "'"; \
             err->code = PGERR_MISSING_FIELD; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_RES(err,tok) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Invalid separator"; \
             err->code = PGERR_INVALID_SEPARATOR; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REV(err,tok,name,type) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Invalid '"; \
             err->message += type; \
             err->message += "' value in field '"; \
             err->message += name; \
             err->message += "'"; \
             err->code = PGERR_INVALID_VALUE; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REO(err,tok) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Invalid object"; \
             err->code = PGERR_INVALID_OBJECT; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
    #define PROTOGEN_REN(err,tok) \
        do { if (err == NULL || err->set) return PROTOGEN_NS::parse_result::ERROR; \
             err->set = true; \
             err->line = tok.line(); err->column = tok.column(); \
             err->message = "Invalid field name"; \
             err->code = PGERR_INVALID_NAME; \
             return PROTOGEN_NS::parse_result::ERROR; } while(false)
#endif

#undef PROTOGEN_TRAIT
#define PROTOGEN_TRAIT(M) \
	namespace PROTOGEN_NS { \
		template<> struct traits<M> { \
            static_assert(std::is_object<M>::value, "Invalid object type"); \
			static void clear( M &value ) { value.clear(); } \
			static void write( PROTOGEN_NS::ostream &out, const M &value ) { value.serialize(out); } \
			static PROTOGEN_NS::parse_result read( PROTOGEN_NS::tokenizer &tok, M &value, \
                bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) { return value.deserialize(tok, required, err); } \
			static void swap( M &a, M &b ) { a.swap(b); } \
		}; \
	}
------

--- CODE_BLOCK_2
namespace PROTOGEN_NS {

enum class parse_result { OK, ERROR, UNDEFINED };

struct ErrorInfo
{
    int code;
    int line;
    int column;
    std::string message;
    bool set;
    ErrorInfo() : code(0), line(0), column(0), set(false) {}
};

// proto3 numerics
template<typename T> struct traits
{
    static_assert(std::is_arithmetic<T>::value, "Invalid arithmetic type");
    static void clear( T &value ) { value = (T) 0; }
    static void write( PROTOGEN_NS::ostream &out, const T &value ) { out << value; }
    static parse_result read( tokenizer &tok, T &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::NUMBER) return parse_result::ERROR;

#if defined(_WIN32) || defined(_WIN64)
        static _locale_t loc = _create_locale(LC_NUMERIC, "C");
        if (loc == NULL) return parse_result::ERROR;
        value = static_cast<T>(_strtod_l(tt.value.c_str(), NULL, loc));
#else
        static locale_t loc = newlocale(LC_NUMERIC_MASK | LC_MONETARY_MASK, "C", 0);
        if (loc == 0) return parse_result::ERROR;
        uselocale(loc);
        value = static_cast<T>(strtod(tt.value.c_str(), NULL));
        uselocale(LC_GLOBAL_LOCALE);
#endif
        return parse_result::OK;
    }
    static void swap( T &a, T &b ) { T temp = a; a = b; b = temp; }
};

// proto3 'bool'
template<> struct traits<bool>
{
    static void clear( bool &value ) { value = false; }
    static void write( PROTOGEN_NS::ostream &out, const bool &value ) { out << ((value) ? "true" : "false"); }
    static parse_result read(tokenizer &tok, bool &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::TRUE && tt.id != token_id::FALSE) return parse_result::ERROR;
        value = tt.id == token_id::TRUE;
        return parse_result::OK;
    }
    static void swap( bool &a, bool &b ) { bool temp = a; a = b; b = temp; }
};

// proto3 'string'
template<> struct traits<std::string>
{
    static void clear( std::string &value ) { value.clear(); }
    static void write( PROTOGEN_NS::ostream &out, const std::string &value )
    {
        out << '"';
        for (std::string::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            switch (*it)
            {
                case '"':  out << "\\\""; break;
                case '\\': out << "\\\\"; break;
                case '/':  out << "\\/"; break;
                case '\b': out << "\\b"; break;
                case '\f': out << "\\f"; break;
                case '\r': out << "\\r"; break;
                case '\n': out << "\\n"; break;
                case '\t': out << "\\t"; break;
                default:   out << *it;
            }
        }
        out << '"';
    }
    static parse_result read( tokenizer &tok, std::string &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::STRING) return parse_result::ERROR;
        value = tt.value;
        return parse_result::OK;
    }
    static void swap( std::string &a, std::string &b ) { a.swap(b); }
};
------

#
# 'repeated' with $1$ as container
#

--- CODE_REPEATED_TRAIT
template <typename T> struct traits< $1$<T> >
{
    static void clear( $1$<T> &value ) { value.clear(); }
    static bool write( PROTOGEN_NS::ostream &out, const $1$<T> &value )
    {
        bool begin = true;
        out << '[';
        for (typename $1$<T>::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            if (!begin) out << ",";
            begin = false;
            traits<T>::write(out, *it);
        }
        out << ']';
        return true;
    }
    static parse_result read( tokenizer &tok, $1$<T> &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::ARRS) return parse_result::ERROR;
        while (true)
        {
            T entry;
            parse_result res = traits<T>::read(tok, entry, required, err);
            if (res == parse_result::ERROR) return parse_result::ERROR;
            if (res == parse_result::OK) value.push_back(entry);
            tt = tok.next();
            if (tt.id != token_id::COMMA) break;
        }
        if (tt.id != token_id::ARRE) return parse_result::ERROR;
        return parse_result::OK;
    }
    static void swap( $1$<T> &a, $1$<T> &b ) { a.swap(b); }
};
------

--- CODE_BLOCK_3

// Base64 encoder/decoder based on Joe DF's implementation
// Original source at <https://github.com/joedf/base64.c> (MIT licensed)
static const char *B64_SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
template <> struct traits< std::vector<uint8_t> >
{
    static void clear( std::vector<uint8_t> &value ) { value.clear(); }
    static int b64_int( int ch )
    {
        if (ch == '+') return 62;
        if (ch == '/') return 63;
        if (ch == '=') return 64;
        if (ch >= '0' && ch <= '9') return ch + 4;
        if (ch >= 'A' && ch <= 'Z') return ch - 'A';
        if (ch >= 'a' && ch <= 'z') return (ch - 'a') + 26;
        return 0;
    }
    static bool write( PROTOGEN_NS::ostream &out, const std::vector<uint8_t> &value )
    {
        char o[5] = { 0 };
        size_t i = 0;
        size_t size = value.size();

        out << '"';

        for (i = 0; i + 2 < size; i += 3)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
            o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) | ((value[i+2] & 0xC0) >> 6) ];
            o[3] = B64_SYMBOLS[ value[i+2] & 0x3F ];
            out << o;
        }

        if (size - i)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) ];
            o[2] = '=';
            o[3] = '=';

            if (size - i == 2)
            {
                o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
                o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) ];
            }

            out << o;
        }
        out << '"';

        return true;
    }
    static parse_result read( tokenizer &tok, std::vector<uint8_t> &array, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;

        token tt = tok.next();
        if (tt.id == token_id::NIL) return parse_result::UNDEFINED;
        if (tt.id != token_id::STRING) return parse_result::ERROR;

        size_t k = 0;
        int s[4];
        const char *ptr = tt.value.c_str();

        while (true)
        {
            // read 4 characters
            for (size_t j = 0; j < 4; ++j)
            {
                int ch = *ptr++;
                if (ch == 0) return (j == 0) ? parse_result::OK : parse_result::ERROR;
                s[j] = PROTOGEN_NS::traits< std::vector<uint8_t> >::b64_int(ch);
            }
            // decode base64 tuple
            array.push_back( (uint8_t) (((s[0] & 0xFF) << 2 ) | ((s[1] & 0x30) >> 4)) );
            if (s[2] != 64)
            {
                array.push_back( (uint8_t) (((s[1] & 0x0F) << 4) | ((s[2] & 0x3C) >> 2)) );
                if ((s[3]!=64))
                {
                    array.push_back( (uint8_t) (((s[2] & 0x03) << 6) | s[3]) );
                    k+=3;
                }
                else
                    k+=2;
            }
            else
                k+=1;
        }
    }
    static void swap( std::vector<uint8_t> &a, std::vector<uint8_t> &b ) { a.swap(b); }
};

// primitive fields
template<typename T> class Field
{
    static_assert(std::is_arithmetic<T>::value, "Invalid arithmetic type");
    protected:
        T value_;
        bool empty_;
    public:
        Field() { clear(); }
        Field( const Field<T> &that ) { this->empty_ = that.empty_; if (!empty_) this->value_ = that.value_; }
        Field( Field<T> &&that ) { this->empty_ = that.empty_; if (!empty_) this->value_.swap(that.value_); }
        void swap( Field<T> &that ) { traits<T>::swap(this->value_, that.value_); traits<bool>::swap(this->empty_, that.empty_); }
        void swap( T &that ) { traits<T>::swap(this->value_, that); empty_ = false; }
        const T &operator()() const { return value_; }
        void operator()(const T &value ) { this->value_ = value; this->empty_ = false; }
        bool empty() const { return empty_; }
        void clear() { traits<T>::clear(value_); empty_ = true; }
        Field<T> &operator=( const Field<T> &that ) { this->empty_ = that.empty_; if (!empty_) this->value_ = that.value_; return *this; }
        Field<T> &operator=( const T &that ) { this->empty_ = false; this->value_ = that; return *this; }
        bool operator==( const T &that ) const { return !this->empty_ && this->value_ == that; }
        bool operator!=( const T &that ) const { return !this->empty_ && this->value_ != that; }
        bool operator==( const Field<T> &that ) const { return this->empty_ == that.empty_ && this->value_ == that.value_;  }
        bool operator!=( const Field<T> &that ) const { return this->empty_ != that.empty_ || this->value_ != that.value_;  }
        explicit operator T() const { return this->value_; }
};

------


--- CODE_PARENT_CLASS
// parent class for messages
class $1$ $2$
{
    public:
        virtual ~$1$() = default;
        virtual void serialize( std::string &out ) const {
            typedef std::back_insert_iterator<std::string> ittype;
            ittype begin(out);
            PROTOGEN_NS::iterator_ostream<ittype> os(begin);
            serialize(os);
        }
        virtual void serialize( std::vector<char> &out ) const {
            typedef std::back_insert_iterator<std::vector<char>> ittype;
            ittype begin(out);
            PROTOGEN_NS::iterator_ostream<ittype> os(begin);
            serialize(os);
        }
        virtual void serialize( std::ostream &out ) const {
            typedef std::ostream_iterator<char> ittype;
            ittype begin(out);
            PROTOGEN_NS::iterator_ostream<ittype> os(begin);
            serialize(os);
        }
        virtual void serialize( PROTOGEN_NS::ostream &out ) const = 0;
        virtual bool deserialize( PROTOGEN_NS::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
            PROTOGEN_NS::tokenizer tok(in);
            int result = this->deserialize(tok, required, err) != PROTOGEN_NS::parse_result::ERROR;
            return result;
        }
        virtual bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
            bool skip = in.flags() & std::ios_base::skipws;
            std::noskipws(in);
            std::istream_iterator<char> end;
            std::istream_iterator<char> begin(in);
            PROTOGEN_NS::iterator_istream<std::istream_iterator<char>> ss(begin, end);
            bool result = this->deserialize(ss, required, err);
            if (skip) std::skipws(in);
            return result;
        }
        virtual bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
            PROTOGEN_NS::iterator_istream<std::string::const_iterator> ss(in.begin(), in.end());
            return this->deserialize(ss, required, err);
        }
        virtual bool deserialize( std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
            PROTOGEN_NS::iterator_istream<std::vector<char>::iterator> ss(in.begin(), in.end());
            return this->deserialize(ss, required, err);
        }
        virtual bool deserialize( const char *in, size_t len, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
            auto begin = PROTOGEN_NS::mem_iterator<char>(in, len);
            auto end = PROTOGEN_NS::mem_iterator<char>(in + len, 0);
            PROTOGEN_NS::iterator_istream<PROTOGEN_NS::mem_iterator<char>> is(begin, end);
            return this->deserialize(is, required, err);
        }
        virtual PROTOGEN_NS::parse_result deserialize( PROTOGEN_NS::tokenizer &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) = 0;
        virtual void clear() = 0;
        virtual bool empty() const = 0;
};
------

--- CODE_STRING_REVEAL
namespace json {
template<typename T>
static std::string reveal( const T *value, size_t length )
{
	std::string result(length, ' ');
	for (size_t i = 0; i < length; ++i)
		result[i] = (T) ((int) value[i] ^ 0x33);
	return result;
}
}
------

--- CODE_BLOCK_4
namespace json {

// Write a complete JSON field
template<typename T>
static bool write( PROTOGEN_NS::ostream &out, bool &first, const std::string &name, const T &value )
{
    if (!first) out << ',';
    out << '"' << name << "\":";
    traits<T>::write(out, value);
    first = false;
    return true;
}

static parse_result next_field( tokenizer &tok )
{
    token tt = tok.next();
    if (tt.id == token_id::COMMA) return parse_result::OK;
    if (tt.id == token_id::OBJE || tt.id == token_id::ARRE)
    {
        tok.unnext();
        return parse_result::OK;
    }
    return parse_result::ERROR;
}

static parse_result ignore_value( tokenizer &tok );

static parse_result ignore_array( tokenizer &tok )
{
    if (tok.next().id != token_id::OBJS) return parse_result::ERROR;

    while (true)
    {
        if (ignore_value(tok) == parse_result::ERROR) return parse_result::ERROR;
        if (tok.next().id != token_id::COMMA) break;
    }
    if (tok.next().id != token_id::OBJE) return parse_result::ERROR;

    return parse_result::OK;
}

static parse_result ignore_object( tokenizer &tok )
{
    if (tok.next().id != token_id::OBJS) return parse_result::ERROR;

    while (true)
    {
        if (tok.next().id != token_id::STRING) return parse_result::ERROR;
        if (tok.next().id != token_id::COLON) return parse_result::ERROR;
        if (ignore_value(tok) == parse_result::ERROR) return parse_result::ERROR;
        if (tok.next().id != token_id::COMMA) break;
    }
    if (tok.next().id != token_id::OBJE) return parse_result::ERROR;

    return parse_result::OK;
}

static parse_result ignore_value( tokenizer &tok )
{
    switch (tok.next().id)
    {
        case token_id::NONE:
            return parse_result::ERROR;
        case token_id::OBJS:
            tok.unnext();
            if (ignore_object(tok) == parse_result::ERROR)
                return parse_result::ERROR;
            break;
        case token_id::ARRS:
            tok.unnext();
            if (ignore_array(tok) == parse_result::ERROR)
                return parse_result::ERROR;
            break;
        case token_id::STRING:
        case token_id::NUMBER:
        case token_id::NIL:
        case token_id::TRUE:
        case token_id::FALSE:
            break;
        default:
            return parse_result::ERROR;
    }
    return parse_result::OK;
}

} // namespace json
} // namespace PROTOGEN_NS

------
